# C Call Graph Generation

## CScout:

CScout is a comprehensive suite designed to analyze and refactor large codebases written in C. It leverages modern hardware capabilities to perform in-depth analysis that surpasses the limitations of traditional compilers and linkers.

## Overview

CScout is a source code analyzer and refactoring browser for collections of C programs. It can process workspaces of multiple projects (we define a project as a collection of C source files that are linked together) mapping the complexity introduced by the C preprocessor back into the original C source code files. CScout takes advantage of modern hardware advances (fast processors and large memory capacities) to analyze C source code beyond the level of detail and accuracy provided by current compilers, linkers, and other source code analyzers. The analysis CScout performs takes into account the identifier scopes introduced by the C preprocessor and the C language proper scopes and namespaces. After the source code analysis CScout can:

  - perform accurate cross project identifier renames,
  - process sophisticated queries on identifiers, files, and functions,
  - locate unused or wrongly-scoped identifiers,
  - identify header files that don't need to be included, and
  - **create call graphs spanning both C functions and function-like macros**

## CScout Execution

The CScout engine (cscout) requires as an argument a processing script, for example a cswc-compiled workspace definition file or the `make.cs` script generated by `csmake`. It will serially process each project and directory parsing the corresponding files specified in the workspace definition file, and then process once more each one of the files examined to establish the location of the identifiers. Note that the bulk of the work is performed in the first pass. During the first pass CScout may report warnings, errors, and fatal errors. Fatal errors will terminate processing, all other errors may result in an incorrect analysis of the particular code fragment. CScout only checks the code to the extend needed to perform its analysis; CScout will hapily process many illegal constructs.

### Automated Generation of the Processing Script
In CScout from version 2.2 and onward you can you can also use the supplied tool csmake to directly generate CScout processing scripts by monitoring a project's make-based build process. For this to work your project's build must (probably) be based on a Unix or Unix-like system, and use make and gcc. The make process can also invoke ld, ar, and mv. Recursive make invocations among different directories are also supported.

The way to use csmake is fairly simple. You first arrange for performing a full build, for example by running

`make clean`

Then, instead of running make on the project's top-level directory you run `csmake`. When the build process has finished, csmake will leave in the directory where you started it a CScout processing script named `make.cs`.





# References
[1] 1.  Georgios-Petros Drosos, Thodoris Sotiropoulos, Diomidis Spinellis and  Dimitris Mitropoulos.  [Bloat beneath Python’s scales: A fine-grained inter-project dependency analysis](https://dimitro.gr/assets/papers/DSSM24.pdf). In  _Proceedings of the 32th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE ’24)_. To appear.
[2] [Artifact for FSE paper](https://github.com/gdrosos/bloat-study-artifact/tree/main) 
[3] [PyCG Repository](https://github.com/gdrosos/PyCG)
[4] [PyCG stitching repository](https://github.com/fasten-project/pycg-stitch)

