# C Call Graph Generation

## CScout:

CScout is a comprehensive suite designed to analyze and refactor large codebases written in C. It leverages modern hardware capabilities to perform in-depth analysis that surpasses the limitations of traditional compilers and linkers.

## Overview

CScout is a source code analyzer and refactoring browser for collections of C programs. It can process workspaces of multiple projects (we define a project as a collection of C source files that are linked together) mapping the complexity introduced by the C preprocessor back into the original C source code files. CScout takes advantage of modern hardware advances (fast processors and large memory capacities) to analyze C source code beyond the level of detail and accuracy provided by current compilers, linkers, and other source code analyzers. The analysis CScout performs takes into account the identifier scopes introduced by the C preprocessor and the C language proper scopes and namespaces. After the source code analysis CScout can:

  - perform accurate cross project identifier renames,
  - process sophisticated queries on identifiers, files, and functions,
  - locate unused or wrongly-scoped identifiers,
  - identify header files that don't need to be included, and
  - **create call graphs spanning both C functions and function-like macros**

## Installation

   1.  Clone the source code from GitHub (https://github.com/dspinellis/cscout)
   2.  Enter the CScout directory with cd cscout
   3.  Run `make`
   4.  Run `make test` (optional, but highly recommended)
   5.  Run `sudo make install`. If you want the installation to use a different directory hierarchy than the default `/usr/local`
    , you can specify this on the command line with the `INSTALL_PREFIX variable`. For example, you run `make install INSTALL_PREFIX=/home/mydir` to install CScout under your home directory or `sudo make install INSTALL_PREFIX=/usr` to install CScout under /usr. 

By default the installation will create in /usr/local/include/cscout headers corresponding to a generic standard C compilation and to your host's specific configuration. If you want to process programs based on other host configurations you can modify these files or create a local version of the files in your home or the project's current directory. 

## Workflow

![image](https://github.com/rafailagln/demoSecOPERA/assets/61935258/121e3788-2672-4920-8103-6fee3a41dcc2)


The CScout engine (cscout) requires as an argument a processing script, for example a cswc-compiled workspace definition file or the `make.cs` script generated by `csmake`. It will serially process each project and directory parsing the corresponding files specified in the workspace definition file, and then process once more each one of the files examined to establish the location of the identifiers. Note that the bulk of the work is performed in the first pass. During the first pass CScout may report warnings, errors, and fatal errors. Fatal errors will terminate processing, all other errors may result in an incorrect analysis of the particular code fragment. CScout only checks the code to the extend needed to perform its analysis; CScout will hapily process many illegal constructs.

### Step 1: Automated Generation of the Processing Script
In CScout from version 2.2 and onward you can you can also use the supplied tool csmake to directly generate CScout processing scripts by monitoring a project's make-based build process. For this to work your project's build must (probably) be based on a Unix or Unix-like system, and use make and gcc. The make process can also invoke ld, ar, and mv. Recursive make invocations among different directories are also supported.

The way to use csmake is fairly simple. You first arrange for performing a full build, for example by running

`make clean`

Then, instead of running make on the project's top-level directory you run `csmake`. When the build process has finished, csmake will leave in the directory where you started it a CScout processing script named `make.cs`.

### Step 2: CScout Execution

#### Refactoring browser
When the processing script `make.cs` has been generated, you can run `cscout make.cs` to let CScout begin analyzing your project:
After processing your files CScout will start operating as a Web server. At that point you must open a Web browser and connect to the location printed on its output. From that point onward your CScout contact is the Web browser interface; only fatal errors and progress indicators will appear on CScout's standard output. Depending on the access control list specified, you may also be able to perform some operations over the network. However, since CScout operates as a single-threaded process, you may experience delays when another user sends a complex query.

#### Call Graph Generation
You can use the option *-R* to make CScout generate call graphs and exit. The option can be specified multiple times. The specification is the type of desired graph (fgraph.txt for a file dependency graph or cgraph.txt for a function and macro call graph), optionally followed by parameters appearing in the corresponding URL of the CScout web interface. The generated text file contains one space-delimited relationship per line. It can be further processed by tools such sas awk and dot to produce graphical output as shown in the following examples.
```
# Create a non-static function call graph and a compile-time file dependency graph
cscout -R cgraph.txt -R fgraph.txt?gtype=C.
```
```
# Convert the generated call graph into an SVG diagram
awk ’
 BEGIN { print "digraph G {" }
 {print "\"" $1 "\" -> \"" $2 "\""}
 END { print "}" }’ cgraph.txt |
dot -Tsvg >cgraph.svg
```

## Demonstration of usage on npm/ncat
We will demonstrate the usage of CScout on https://github.com/nmap/nmap/tree/master/ncat.

Ncat, short for Nmap Network Connector, is a versatile command-line tool used for network communication and data exchange. It's often seen as a more advanced and feature-rich alternative to the classic Netcat utility.

### Step 1: Clone the repository and switch to nmap directory
```
git clone git@github.com:nmap/nmap.git
cd nmap
```

### Step 2: Generate Makefiles through GNU Autoconf 
This step is not necessary in every project
```
./configure
```
### Step 3: Generate processing script through `csmake` for ncat 
```
cd ncat
csmake 
```
### Step 4: Run CScout in browser mode (Option 1 - see below for Option 2)
```
cscout make.cs
```
### Step 5: View Non-Static Function Call Graph through browser
If the default port was used, the non-static function call graph will be visible at http://localhost:8081/cgraph.svg

### Step 6: Observe Metrics
For bloated functions, we can directly observe **Writable functions that are not directly called** or make custom queries for more granularity through **Specify new function query**



### Step 4: Produce Call Graphs and exit (Option 2)
Create a non-static function call graph and a compile-time file dependency graph
```
cscout make.cs -R cgraph.txt -R fgraph.txt?gtype=C
```
## Identifying bloated code
-  Reachability analysis through call graph (i.e., functions reachable through `main`
-  Function queries through browser










